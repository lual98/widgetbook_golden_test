import 'dart:async';
import 'dart:io';

import 'package:alchemist/alchemist.dart';
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mocktail/mocktail.dart';
import 'package:widgetbook/widgetbook.dart';
import 'package:widgetbook_golden_test/src/golden_play_action.dart';
import 'package:widgetbook_golden_test/src/ignore_network_image_exception.dart';
import 'package:widgetbook_golden_test/src/test_http_overrides.dart';
import 'package:widgetbook_golden_test/src/widget_tester_extension.dart';
import 'package:widgetbook_golden_test/src/widgetbook_golden_test_builder.dart';
import 'package:widgetbook_golden_test/src/widgetbook_golden_tests_properties.dart';
// ignore: implementation_imports
import 'package:widgetbook/src/addons/addons.dart';

class _WidgetbookStateMock extends Mock implements WidgetbookState {}

class _BuildContextMock extends Mock implements BuildContext {}

/// Creates and runs a golden test of the given Widgetbook [useCase].
/// The golden snapshot is saved in [goldenSnapshotsOutputPath]
void createGoldenTest(
  WidgetbookUseCase useCase,
  String goldenSnapshotsOutputPath,
  WidgetbookGoldenTestsProperties properties,
) {
  // Skip the golden test case if it contains the [skip-golden] tag.
  bool shouldSkip = useCase.name.contains(properties.skipTag);

  // Golden test case of the story.
  testWidgets(useCase.name, (widgetTester) async {
    final previousOnError = FlutterError.onError;
    await runZonedGuarded<Future<void>>(
      () async {
        await HttpOverrides.runZoned(() async {
          FlutterError.onError = (FlutterErrorDetails details) async {
            // Ignore image loading errors for generated by the mocked http client.
            handleError(details, properties, previousOnError);
          };

          late Widget widgetToTest;
          try {
            widgetToTest = await widgetTester.pumpWidgetbookCase(
              properties,
              useCase,
            );
          } finally {
            // Restore the previous error handler
            FlutterError.onError = previousOnError;
          }

          await expectLater(
            find.byType(widgetToTest.runtimeType).first,
            matchesGoldenFile("$goldenSnapshotsOutputPath/${useCase.name}.png"),
          );

          try {
            WidgetbookGoldenTestBuilder goldenTestBuilder = widgetTester
                .firstWidget(find.byType(WidgetbookGoldenTestBuilder));

            if (goldenTestBuilder.goldenActions != null) {
              for (final play in goldenTestBuilder.goldenActions!) {
                await validatePlayFunction(
                  widgetTester,
                  properties,
                  useCase,
                  play,
                  widgetToTest,
                  goldenSnapshotsOutputPath,
                );
              }
            }
          } catch (_) {
            // Golden Test Builder was not found, continue normally.
          }
        }, createHttpClient: (_) => createHttpClient(properties));
      },
      (error, stack) {
        var details = FlutterErrorDetails(
          exception: error,
          stack: stack,
          context: ErrorDescription(error.toString()),
        );
        handleError(details, properties, previousOnError);
      },
    );
  }, skip: shouldSkip);
}

Future<void> validatePlayFunction(
  WidgetTester widgetTester,
  WidgetbookGoldenTestsProperties properties,
  WidgetbookUseCase useCase,
  GoldenPlayAction play,
  Widget widgetToTest,
  String goldenSnapshotsOutputPath,
) async {
  await widgetTester.pumpWidgetbookCase(properties, useCase);
  await play.callback(widgetTester, find);
  await widgetTester.pumpAndSettle();
  Finder goldenFinder =
      play.goldenFinder == null
          ? find.byType(widgetToTest.runtimeType).first
          : play.goldenFinder!.call(find);
  await expectLater(
    goldenFinder,
    matchesGoldenFile(
      "$goldenSnapshotsOutputPath/${useCase.name} - ${play.name}.png",
    ),
  );
}

@visibleForTesting
void handleError(
  FlutterErrorDetails details,
  WidgetbookGoldenTestsProperties properties,
  Function(FlutterErrorDetails)? previousOnError,
) {
  // Ignore image loading errors for generated by the mocked http client.
  if (details.exception is IgnoreNetworkImageException) {
    return;
  }

  if (properties.onTestError != null) {
    properties.onTestError!(details, previousOnError);
  } else {
    previousOnError?.call(details);
  }
}

void createGoldenTestAlchemist(
  WidgetbookUseCase useCase,
  String goldenSnapshotsOutputPath,
  WidgetbookGoldenTestsProperties properties,
) {
  bool shouldSkip = useCase.name.contains(properties.skipTag);
  WidgetbookGoldenTestBuilder? goldenTestBuilder;
  try {
    var widgetbookStateMock = _WidgetbookStateMock();
    when(() => widgetbookStateMock.queryParams).thenReturn({});
    when(
      () => widgetbookStateMock.knobs,
    ).thenReturn(KnobsRegistry(onLock: () {}));
    when(() => widgetbookStateMock.addons).thenReturn(properties.addons);
    when(() => widgetbookStateMock.previewMode).thenReturn(true);
    final widget = WidgetbookScope(
      state: widgetbookStateMock,
      child: useCase.builder(_BuildContextMock()),
    );
    if (widget.child is WidgetbookGoldenTestBuilder) {
      goldenTestBuilder = widget.child as WidgetbookGoldenTestBuilder;
    }
  } catch (e) {
    print(e);
    print(useCase.name);
  }

  goldenTest(
    useCase.name,
    fileName: "$goldenSnapshotsOutputPath/${useCase.name}",
    skip: shouldSkip,
    pumpWidget: (tester, widget) async {
      final previousOnError = FlutterError.onError;
      await runZonedGuarded<Future<void>>(
        () async {
          await HttpOverrides.runZoned(() async {
            FlutterError.onError = (FlutterErrorDetails details) async {
              // Ignore image loading errors for generated by the mocked http client.
              handleError(details, properties, previousOnError);
            };

            try {
              await tester.pumpWidget(widget);
              await tester.pumpAndSettle();
              await tester.precacheImagesAndWait(properties);
              await tester.pumpAndSettle();
              print("Finished pumping test for ${useCase.name}");
            } finally {
              // Restore the previous error handler
              FlutterError.onError = previousOnError;
            }
          }, createHttpClient: (_) => createHttpClient(properties));
        },
        (error, stack) {
          var details = FlutterErrorDetails(
            exception: error,
            stack: stack,
            context: ErrorDescription(error.toString()),
          );
          handleError(details, properties, previousOnError);
        },
      );
    },
    builder: () {
      var widgetbookStateMock = _WidgetbookStateMock();
      when(() => widgetbookStateMock.queryParams).thenReturn({});
      when(
        () => widgetbookStateMock.knobs,
      ).thenReturn(KnobsRegistry(onLock: () {}));
      when(() => widgetbookStateMock.addons).thenReturn(properties.addons);
      when(() => widgetbookStateMock.previewMode).thenReturn(true);
      return GoldenTestScenario(
        constraints: BoxConstraints(
          maxWidth: 200,
          maxHeight: 200,
        ), // TODO: This will have to be parametrized
        name: useCase.name,
        child: WidgetbookScope(
          state: widgetbookStateMock,
          child: MultiAddonBuilder(
            addons: properties.addons,
            builder: (context, addon, child) {
              final newSetting = addon.valueFromQueryGroup({});
              return addon.buildUseCase(context, child, newSetting);
            },
            child: Builder(
              builder: (context) {
                return useCase.builder(context);
              },
            ),
          ),
        ),
      );
    },
  );
  if (goldenTestBuilder?.goldenActions != null) {
    for (final action in goldenTestBuilder!.goldenActions!) {
      goldenTest(
        '${useCase.name} - ${action.name}',
        fileName: "$goldenSnapshotsOutputPath/${useCase.name} - ${action.name}",
        skip: shouldSkip,
        pumpWidget: (tester, widget) async {
          final previousOnError = FlutterError.onError;
          await runZonedGuarded<Future<void>>(
            () async {
              await HttpOverrides.runZoned(() async {
                FlutterError.onError = (FlutterErrorDetails details) async {
                  // Ignore image loading errors for generated by the mocked http client.
                  handleError(details, properties, previousOnError);
                };

                try {
                  await tester.pumpWidget(widget);
                  await tester.pumpAndSettle();
                  await tester.precacheImagesAndWait(properties);
                  await tester.pumpAndSettle();
                  await action.callback(tester, find);
                  print("Finished pumping test for ${useCase.name}");
                } finally {
                  // Restore the previous error handler
                  FlutterError.onError = previousOnError;
                }
              }, createHttpClient: (_) => createHttpClient(properties));
            },
            (error, stack) {
              var details = FlutterErrorDetails(
                exception: error,
                stack: stack,
                context: ErrorDescription(error.toString()),
              );
              handleError(details, properties, previousOnError);
            },
          );
        },
        builder: () {
          var widgetbookStateMock = _WidgetbookStateMock();
          when(() => widgetbookStateMock.queryParams).thenReturn({});
          when(
            () => widgetbookStateMock.knobs,
          ).thenReturn(KnobsRegistry(onLock: () {}));
          when(() => widgetbookStateMock.addons).thenReturn(properties.addons);
          when(() => widgetbookStateMock.previewMode).thenReturn(true);
          return GoldenTestScenario(
            constraints: BoxConstraints(
              maxWidth: 200,
              maxHeight: 200,
            ), // TODO: This will have to be parametrized
            name: useCase.name,
            child: WidgetbookScope(
              state: widgetbookStateMock,
              child: MultiAddonBuilder(
                addons: properties.addons,
                builder: (context, addon, child) {
                  final newSetting = addon.valueFromQueryGroup({});
                  return addon.buildUseCase(context, child, newSetting);
                },
                child: Builder(
                  builder: (context) {
                    return useCase.builder(context);
                  },
                ),
              ),
            ),
          );
        },
      );
    }
  }
}
